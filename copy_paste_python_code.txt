import os
import torch
import torch.nn as nn
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
from tqdm import tqdm

# CUDA support 
if torch.cuda.is_available():
    device = torch.device('cuda')
else:
    device = torch.device('cpu')
torch.set_default_device(device)

print(f"\nUsing device: {device}\n\n")

def exact_solution(d, w0, t):
    "Defines the analytical solution to the under-damped harmonic oscillator problem above."
    assert d < w0
    w = np.sqrt(w0**2-d**2)
    phi = np.arctan(-d/w)
    A = 1/(2*np.cos(phi))
    cos = torch.cos(phi+w*t)
    exp = torch.exp(-d*t)
    u = exp*2*A*cos
    return u

class FCN(nn.Module):
    "Defines a standard fully-connected network in PyTorch"

    def __init__(self, N_INPUT, N_OUTPUT, N_HIDDEN, N_LAYERS):
        super().__init__()
        activation = nn.Tanh
        self.fcs = nn.Sequential(*[
                        nn.Linear(N_INPUT, N_HIDDEN),
                        activation()])
        self.fch = nn.Sequential(*[
                        nn.Sequential(*[
                            nn.Linear(N_HIDDEN, N_HIDDEN),
                            activation()]) for _ in range(N_LAYERS-1)])
        self.fce = nn.Linear(N_HIDDEN, N_OUTPUT)

    def forward(self, x):
        x = self.fcs(x)
        x = self.fch(x)
        x = self.fce(x)
        return x

if __name__ == "__main__":

    # first, create some noisy observational data
    torch.manual_seed(123)
    EPOCHS = 500001   
    d, w0 = 2, 20
    t_obs = torch.rand(40).view(-1,1)
    u_obs = exact_solution(d, w0, t_obs) + 0.04*torch.randn_like(t_obs)
    t_test = torch.linspace(0,1,300).view(-1,1)
    u_exact = exact_solution(d, w0, t_test)

    print(f"True value of mu: {2*d}")
    print(f"True value of k: {w0**2}")
    print(f"u_exact square mean: {torch.sqrt(torch.mean(u_exact**2))}")


    path_name = 'save_imgs'
    current_dir = os.getcwd()
    SAVE_DIR = os.path.join(current_dir,path_name)
    try:
        os.mkdir(SAVE_DIR)
    except:
        pass

    path_gif_name = 'gif'
    SAVE_GIF_DIR = os.path.join(SAVE_DIR,path_gif_name)
    try:
        os.mkdir(SAVE_GIF_DIR)
    except:
        pass

    torch.manual_seed(123)

    # define a neural network to train
    # N_INPUT, N_OUTPUT, N_HIDDEN, N_LAYERS
    pinn = FCN(1,1,32,3)

    # define training points over the entire domain, for the physics loss
    t_physics = torch.linspace(0,1,30).view(-1,1).requires_grad_(True)

    # train the PINN
    d, w0 = 2, 20
    mu, k = 2*d, w0**2

    # treat mu as a learnable parameter
    # TODO: write code here
    mu_nn = torch.nn.Parameter(torch.zeros(1, requires_grad=True))
    k_nn = torch.nn.Parameter(torch.zeros(1, requires_grad=True))
    mus = []
    files = []
    losses=[]

    # add mu to the optimiser
    # TODO: write code here
    optimiser = torch.optim.Adam(list(pinn.parameters())+[mu_nn, k_nn],lr=1e-3)
    for i in tqdm(range(EPOCHS)):
        optimiser.zero_grad()

        # compute each term of the PINN loss function above
        # using the following hyperparameters:
        lambda1 = 10**4

        # compute physics loss
        u = pinn(t_physics)
        dudt = torch.autograd.grad(u, t_physics, torch.ones_like(u), create_graph=True)[0]
        d2udt2 = torch.autograd.grad(dudt, t_physics, torch.ones_like(dudt), create_graph=True)[0]
        loss1 = torch.mean((d2udt2 + mu_nn*dudt + k_nn*u)**2)

        # compute data loss
        # TODO: write code here
        u = pinn(t_obs)
        loss2 = torch.mean((u - u_obs)**2)

        # backpropagate joint loss, take optimiser step
        loss = loss1 + lambda1*loss2
        loss.backward()
        optimiser.step()

        # record mu value
        # TODO: write code here
        mus.append([mu_nn.item(),
                    k_nn.item()])
        losses.append([loss1.item(),loss2.item(),loss.item()])

        # plot the result as training progresses
        if i % 1250 == 0:
            fig = plt.figure(figsize=(12,5))
            u = pinn(t_test).detach()
            plt.scatter(t_obs[:,0], u_obs[:,0], label="Noisy observations", alpha=0.6)
            plt.plot(t_test[:,0], u[:,0], label="PINN solution", color="tab:green")
            plt.title(f"Training step {i}")
            plt.legend()

            file = os.path.join(SAVE_GIF_DIR,"pinn_%.8i.png"%(i+1))
            plt.savefig(file, bbox_inches='tight', pad_inches=0.1, dpi=100, facecolor="white")
            files.append(file)
            plt.close(fig)


    mus_np = np.array(mus)
    losses_np = np.array(losses)

    fig = plt.figure()
    plt.title("mu")
    plt.plot(list(mus_np[:,0]), label="PINN estimate")
    plt.hlines(2*d, 0, len(mus_np), label="True value", color="tab:green")
    plt.legend()
    plt.xlabel("Training step")
    plt.savefig(os.path.join(SAVE_DIR,"mu.png"), bbox_inches='tight', pad_inches=0.1, dpi=100, facecolor="white")
    plt.close(fig)

    fig = plt.figure()
    plt.title("k")
    plt.plot(list(mus_np[:,1]), label="PINN estimate")
    plt.hlines(w0**2, 0, len(mus_np), label="True value", color="tab:green")
    plt.legend()
    plt.xlabel("Training step")
    plt.savefig(os.path.join(SAVE_DIR,"k.png"), bbox_inches='tight', pad_inches=0.1, dpi=100, facecolor="white")
    plt.close(fig)

    fig = plt.figure()
    plt.title("Losses")
    plt.subplot(3,1,1)
    plt.plot(list(losses_np[:,0]), label="Physical loss")
    plt.legend()
    plt.subplot(3,1,2)
    plt.plot(list(losses_np[:,1]), label="Data loss")
    plt.legend()
    plt.subplot(3,1,3)
    plt.plot(list(losses_np[:,2]), label="Total loss")
    plt.legend()
    plt.xlabel("Training step")
    plt.savefig(os.path.join(SAVE_DIR,"Losses.png"), bbox_inches='tight', pad_inches=0.1, dpi=100, facecolor="white")
    plt.close(fig)

    def save_gif_PIL(outfile, files, fps=5, loop=0):
        "Helper function for saving GIFs"
        imgs = [Image.open(file) for file in files]
        imgs[0].save(fp=outfile, format='GIF', append_images=imgs[1:], save_all=True, duration=int(1000/fps), loop=loop)

    save_gif_PIL(os.path.join(SAVE_DIR,"learning_k_mu.gif"), files, fps=60, loop=0)